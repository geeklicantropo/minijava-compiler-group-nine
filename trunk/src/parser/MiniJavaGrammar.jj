/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(eg1)package parser;

public class eg1
{
  public static void main(String args []) throws ParseException
  {
    eg1 parser = new eg1(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Entre com o programa na linguagem miniJava. Fim de arquivo = $ :");
      try
      {
        switch (eg1.Program())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Goodbye.");
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        eg1.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
}

PARSER_END(eg1)

SKIP: { " "
| "\n"
| "\r" 
| "\r\n"
}

TOKEN : {
  < AND: "&&" >
| < LESS: "<" >
| < EQUAL: "=" >
| < TIMES: "*" >
| < PLUS: "+" >
| < MINUS: "-" >
| < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < STRING: "String" >
| < EXTENDS: "extends" >
| < LENGTH: "length" >
| < RETURN: "return" >
| < INT: "int" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < NEW: "new" >
| < BOOLEAN: "boolean" > 
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" > 
| < PRINT: "System.out.println" >
| < TRUE: "true" >
| < FALSE: "false" >
| < THIS: "this" >
| < NOT: "!" >
| < DOLAR: "$" >
}

TOKEN : {
  < #DIGIT: ["0"-"9"] >
| < #LETTER: ["a"-"z"]|["A"-"Z"] >
| < ID: <LETTER> (<LETTER> | "_" | <DIGIT>)* >
| < NUM: (<DIGIT>)+ >
}


int Start() :
{
Token t;
int i;
int value;
}
{
	t = <NUM> 
	{ i = Integer.parseInt(t.image); }
	{ value = i; }
	
	(
		<PLUS>
		t = <NUM>
		{ i = Integer.parseInt(t.image); }
		{ value += i; }
	)*		
	<EOF>
	{ return value; }
}


void Exp() :
{}
{
					<TRUE> Exp_()
	| 				<FALSE> Exp_() 
	| 				<ID> Exp_()
	| 				<THIS> Exp_()
	| LOOKAHEAD(2) 	<NEW> <INT> "[" Exp() "]" Exp_() 
	| 				<NEW> <ID> "(" ")" Exp_()
	| 				"(" Exp() ")" Exp_()
	| 				<NUM> Exp_()
	|			 	"!" Exp() Exp_()
	<EOF>
}

void ExpList():
{}
{
	Exp() (ExpRest())*	
	|{} 
}

void ExpRest():
{}
{
	"," Exp()
}

void Exp_():
{}
{
	 OpExp() Exp() Exp_()
	 | 				"[" Exp() "]" Exp_()
	 |LOOKAHEAD(2)	"." <LENGTH> Exp_()
	 | 				"." <ID> "(" ExpList() ")" Exp_()
	 |{} 
}	 


void OpExp():
{}
{
	<PLUS>
	| <MINUS>
	| <TIMES>
	| <AND>
	| <LESS>
}

void Type():
{}
{
	LOOKAHEAD(2) < INT > "[" "]"
	| < BOOLEAN >
	| < INT >
	| < ID >
}

void FormalRest():
{}
{
  "," Type() < ID >
}


void VarDecl () :
{}
{
  Type() < ID >  < SEMICOLON >
}
  

void FormalList () :
{}
{
	Type() < ID > (FormalRest())*
	|{}
	
}

void Statement () :
{}
{
	< LBRACE >	(Statement())* < RBRACE>
	|<IF> < LPAREN > Exp() < RPAREN > Statement() < ELSE >  Statement()
	|< WHILE > < LPAREN > Exp() < RPAREN > Statement() 
	|< PRINT > < LPAREN > Exp() <RPAREN > < SEMICOLON >
	|LOOKAHEAD (2) < ID > < EQUAL > Exp() < SEMICOLON>
	|LOOKAHEAD (2) < ID > < LBRACKET > < RBRACKET > Exp() <  EQUAL > Exp() < SEMICOLON > 
}

void MainClass():
{}
{
  < CLASS > < ID > < LBRACE > < PUBLIC > < STATIC > < VOID > < MAIN > <LPAREN > < STRING > < LBRACKET>< RBRACKET > < ID > <RPAREN > < LBRACE > Statement() < RBRACE > <RBRACE >
}

void ClassDecl () :
{}
{
	LOOKAHEAD (3) < CLASS > < ID > < LBRACE > (VarDecl())* (MethodDecl())* < RBRACE > 
   |LOOKAHEAD (3) < CLASS > < ID > < EXTENDS > < ID > < LBRACE >  (VarDecl())* (MethodDecl())* < RBRACE > 
}


void MethodDecl():
{
}
{
  < PUBLIC > Type() < ID > < LPAREN > FormalList() < RPAREN  > < LBRACE > (VarDecl())* (Statement())* < RETURN > Exp() < SEMICOLON > < RBRACE >
}



int Program () :
{}
{
   MainClass() (ClassDecl())*  < DOLAR >
  {
    return 0;
  }
| < DOLAR >
  {
    return 1;
  }
}